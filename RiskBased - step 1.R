####################################################

# Load the data and look at it:
Random<-c(221, 3851, 4072)
NonRandom<-c(407, 1629, 2036)

#Structures:

#Random
#Positives    Negatives   Tested

#NonRandom
#Positives    Negatives   Tested

## The data:
Random
NonRandom


#Parameters for test:
sea=57      #parameters for Se - 0.85 (0.70–0.95)
seb=12     
spa=1000       #parameters for Sp - 0.77 (0.49–0.96)
spb=1

## Load the runjags package and define the model:
library("runjags")


modelRB <- '
model{

#If the test used in Random and Non-Random groups is the same
#It is better to have in the same model both groups,
#in order to have the results based on the same estimates
#of Se and Sp in both groups

#Random group

Random[1]~dbin(apR, Random[3])

apR<-p*Se+(1-p)*(1-Sp)   #Likelihood

#Non-random group

NonRandom[1]~dbin(apNR, NonRandom[3])

apNR<-pNR*Se+(1-pNR)*(1-Sp)


#PRIORS
p~dbeta(1,2)  #Prior for the distribution of prevalence in Random group

pNR~dbeta(1,2)  #Prior for the distribution of p in NonRandom group

#The other PRIORS
	Se ~ dbeta(57.35,12.589)              #Prior for Sensitivity
	Sp ~ dbeta(1000,1)              #Prior for Specificity

#data# Random, NonRandom
#monitor# p, pNR, Se, Sp
#inits# p, pNR, Se, Sp, 


}

'
# The initial values we need:
p <- list(chain1=0.01, chain2=0.04)
pNR <- list(chain1=0.1, chain2=0.4)
Se <- list(chain1=0.5, chain2=0.95)
Sp <- list(chain1=0.95, chain2=0.5)



# Run the model:
resultsRB <- run.jags(modelRB, n.chains=2, burnin = 5000000, sample = 10000, adapt = 1000,thin=10)

resultsRB

write.csv(summary(resultsRB), file='resultsRB.csv')

plot(resultsRB)

## Extract MCMC chains:
library('coda')

chains<-as.mcmc(resultsRB)

write.csv(chains,file='ChainsRB.csv')

##############################
m<-as.numeric(NA)
v<-as.numeric(NA)
alpha<-as.numeric(NA)
beta<-as.numeric(NA)


#Now we calculate the mean and varians of the values generated by the model and stored in the chains
#m[1] and v[1] are the mean and variance for the variable p
#m[2] and v[2] are for pNR
#m[3] and v[3] are for Se
#m[4] and v[4] are for Sp

#From these means and variances, we calculate the paameters Alpha and Beta of the corresponding posterior beta distributions

for(i in 1:4){
  
m[i]<-mean(chains[,i])
v[i]<-var(chains[,i])
alpha[i]<-((m[i]^2-m[i]^3-m[i]*v[i])/v[i])
beta[i]<-((m[i]-2*m[i]^2+m[i]^3-v[i]+m[i]*v[i])/v[i])

}

#The following graphs compare the generated posterior distributions to the distributions described by the Alpha and Beta parameters calculated above

hist(chains[,1], freq = FALSE, xlim=c(0,1), col = "grey", main='p')
curve(dbeta(x,alpha[1],beta[1]),col='RED', add=TRUE)

hist(chains[,2], freq = FALSE, xlim=c(0,1), col = "grey", main='pNR')
curve(dbeta(x,alpha[2],beta[2]),col='red', add=TRUE)

hist(chains[,3], freq = FALSE, xlim=c(0,1), col = "grey", main='Se')
curve(dbeta(x,alpha[3],beta[3]),col='blue', add=TRUE)

hist(chains[,4], freq = FALSE, xlim=c(0,1), col = "grey", main='Sp')
curve(dbeta(x,alpha[4],beta[4]),col='blue', add=TRUE)


#Estimation of Odds Ratios

meanOR<-as.numeric(NA)
varOR<-as.numeric(NA)
sd<-as.numeric(NA)


meanOR<-alpha[2]*beta[1]/((beta[2]-1)*(alpha[1]-1))
varOR<-alpha[2]*(alpha[2]+1)*(beta[1]-1)*beta[1]/((beta[2]-1)*(beta[2]-2)*(alpha[1]-1)*(alpha[1]-2))-(alpha[2]*beta[1]/((beta[2]-1)*(alpha[1]-1)))^2

sd<-sqrt(varOR) #the standard deviation of the odds ratio is required to graph their distribution


meanOR
varOR

ORs<-cbind(meanOR,varOR)

write.csv(ORs,file='ORs.csv')

curve(dnorm(x,meanOR,sd),col='blue', xlim=c(-10,10))

